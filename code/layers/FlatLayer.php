<?php

/**
 * @author marcus
 */
class FlatLayer extends ViewableData
{
    protected static $_cache_db = array();
    protected static $_cache_layers = array();
    
    protected $name;

    protected $config = array();

    private static $virtual_db = array(
        'Title'         => 'Text',
    );

    private static $virtual_layers = array();

    private static $virtual_relations = array(
        
    );

    public function __construct($name)
    {
        $this->name = $name;
        parent::__construct();
    }

    public function getName() {
        return $this->name;
    }

    public function db($fieldName = null) {
        return $this->virtualDb($fieldName);
    }

    public function virtualDb($fieldName = null) {
        $classes = ClassInfo::ancestry($this, false);

        // If we're looking for a specific field, we want to hit subclasses first as they may override field types
        if($fieldName) {
			$classes = array_reverse($classes);
		}
		
		$items = array();
		foreach($classes as $class) {
			if(isset(self::$_cache_db[$class])) {
				$dbItems = self::$_cache_db[$class];
			} else {
				$dbItems = (array) Config::inst()->get($class, 'virtual_db', Config::UNINHERITED);

                // and add in those from any related items
                $related = Config::inst()->get($class, 'virtual_relations', Config::UNINHERITED);
                if ($related) {
                    foreach ($related as $rel) {

                    }
                }

                $layersDb = self::db_for_layers(get_class($this));
                

				self::$_cache_db[$class] = $dbItems;
			}

            if ($fieldName && isset($dbItems[$fieldName])) {
                return $dbItems[$fieldName];
            }

            // Validate the data
            foreach($dbItems as $k => $v) {
                if(!is_string($k) || is_numeric($k) || !is_string($v)) {
                    user_error("$class::\$db has a bad entry: "
                    . var_export($k,true). " => " . var_export($v,true) . ".  Each map key should be a"
                    . " property name, and the map value should be the property type.", E_USER_ERROR);
                }
            }

            $items = isset($items) ? array_merge((array) $items, $dbItems) : $dbItems;
		}

		return $items;
    }

    public function has_one() {
        return array();
    }

    public function setConfig($name, $value) {
        $this->config[$name] = $value;
    }

    public function getConfig($name, $default = null) {
        if (isset($this->config[$name])) {
            return $this->config[$name];
        }
        return $default;
    }

    public function getCMSFields() {
        $scaffolder = FormScaffolder::create($this);
        return $scaffolder->getFieldList();
    }


    /**
	 * Return the DBField object that represents the given field.
	 * This works similarly to obj() with 2 key differences:
	 *   - it still returns an object even when the field has no value.
	 *   - it only matches fields and not methods
	 *   - it matches foreign keys generated by has_one relationships, eg, "ParentID"
	 *
	 * @param string $fieldName Name of the field
	 * @return DBField The field as a DBField object
	 */
	public function dbObject($fieldName) {
		if($helper = $this->db($fieldName)) {
			$obj = Object::create_from_string($helper, $fieldName);
			$obj->setValue($this->$fieldName, $this->record, false);
			return $obj;

		// Special case for has_one relationships
		} else if(preg_match('/ID$/', $fieldName) && $this->has_one(substr($fieldName,0,-2))) {
			$val = $this->$fieldName;
			return DBField::create_field('ForeignKey', $val, $fieldName, $this);
		}
	}

    public function fieldLabel($field) {
        return $field;
    }

    public static function db_for_layers($type) {
        if (isset(self::$_cache_layers[$type])) {
            return self::$_cache_layers[$type];
        }

        $layers = self::layers_for($type);
        $fields = array();

        foreach ($layers as $l) {
            $db = $l->db();
            foreach ($db as $name => $type) {
                $fieldName = $l->getName() . '__' . $name;
                $fields[$fieldName] = $type;
            }
        }
        
        self::$_cache_layers[$type] = $fields;
        return self::$_cache_layers[$type];
    }

    public static function layers_for($type) {
        if (is_object($type)) {
            $type = get_class($type);
        }
        $layers = ArrayList::create();
        $def = Config::inst()->get($type, 'virtual_layers');
        if ($def) {
            foreach (Config::inst()->get($type, 'virtual_layers') as $id => $config) {
                if (!is_array($config)) {
                    $config = array('type'      => $config, 'name' => $id);
                }
                $type = $config['type'];
                $layer = $type::create($id);
                $layers->push($layer);
            }
        }

        return $layers;
    }

    public static function layered_form_fields_for($item) {
        $layers = self::layers_for($item);

        $fullList = FieldList::create();
        foreach ($layers as $layer) {
            $scaffolder = FormScaffolder::create($layer);
            $scaffolded = $scaffolder->getFieldList();
            $fullList->merge($scaffolded);
        }
        return $fullList;
    }
}